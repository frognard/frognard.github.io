


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hex Terrain Generator</title>
    <style>
        body {
            margin: 0;
            background-color: #f4f4f4;
        }
        canvas {
            display: block;
            margin: -30px auto 0 auto;
            padding: 0;
          
        }
        #legend {
            text-align: center;
            padding: 10px;
            background-color: #eee;
            font-family: Arial, sans-serif;
            position: fixed; /* Keep it visible at the top */
            width: 100%;
            margin: 0px;
            top: 0;
        }
        #terrainReferenceBar {
            text-align: center;
            padding: 10px;
            background-color: #ddd;
            font-family: Arial, sans-serif;
            position: relative; /* Make sure it can be positioned */
            top: -60px; /* Move it 20px up */
       }
    </style>
</head>
<body>
    <canvas id="hexCanvas"></canvas>
    <div id="legend" style="text-align: center; padding: 10px; background-color: #eeeeee; font-family: Arial, sans-serif;"></div>
    <div>
      
        <style>
            #width, #height {
              width: 50px;
              margin-right: 10px;
              
            }
            button {
              padding: 5px 10px;
            }
            div {
              margin-bottom: 30px;
              text-align: center;
              margin: 40px;
              margin-top: -50px;
            }
          </style>
          
        <!-- Add the width and height textboxes -->
        <label for="width">Î Î»Î¬Ï„Î¿Ï‚:</label>
        <input type="number" id="width" name="width" min="1" value="16">
        <label for="height">ÎÏˆÎ¿Ï‚:</label>
        <input type="number" id="height" name="height" min="1" value="12">
        
        <!-- Add the generate button -->
        <button id="generateButton">Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î± Î§Î¬ÏÏ„Î·</button>
      </div>

      <div id="terrainReferenceBar" style="text-align: center; padding: 10px; background-color: #eeeeee; font-family: Arial, sans-serif;"></div>

    <script>
// Constants
const hexRadius = 30;
let mapWidth = 20;  // Number of columns
let mapHeight = 12; // Number of rows



const terrainColors = {
    "Plains": "#C0CF8C",
    "Forest": "#327129",
    "Hill": "#B7A762",
    "Mountain": "#827746",
    "Lake": "#4682B4",
    "Swamp": "#6B8E23"
};

const metabasisMap = {
    "Plains": "Forest",
    "Forest": "Plains",
    "Hill": "Mountain",
    "Mountain": "Hill",
    "Lake": "Swamp",
    "Swamp": "Lake"
};

const hexContentTable = {
            Plains: [
                [11, 25, "ğŸ "], [26, 42, "â›ª"], [43, 52, "ğŸ’€"],
                [53, 55, "ğŸª¦"], [56, 63, "ğŸŒ²"], [64, 65, "âš¡"], [66, "ğŸŒ€"]
            ],
            Forest: [
                [11, 16, "ğŸ "], [21, 31, "â›ª"], [32, 46, "ğŸ’€"],
                [51, 53, "ğŸª¦"], [54, 61, "ğŸŒ²"], [62, 64, "âš¡"], [65, 66, "ğŸŒ€"]
            ],
            Hill: [
                [11, 22, "ğŸ "], [23, 33, "â›ª"], [34, 46, "ğŸ’€"],
                [51, 53, "ğŸª¦"], [54, 61, "ğŸŒ²"], [62, 63, "âš¡"], [64, 66, "ğŸŒ€"]
            ],
            Mountain: [
                [11, 15, "ğŸ "], [16, 24, "â›ª"], [25, 44, "ğŸ’€"],
                [45, 51, "ğŸª¦"], [52, 55, "ğŸŒ²"], [56, 63, "âš¡"], [64, 66, "ğŸŒ€"]
            ],
            Swamp: [
                [11, 13, "ğŸ "], [14, 16, "â›ª"], [21, 36, "ğŸ’€"],
                [41, 52, "ğŸª¦"], [53, 56, "ğŸŒ²"], [61, 64, "âš¡"], [65, 66, "ğŸŒ€"]
            
            ],
            Lake: [
                [11, 13, ""], [14, 16, ""], [21, 36, ""],
                [41, 52, ""], [53, 56, ""], [61, 64, ""], [65, 66, ""]
        ]
        };

const hexWidth = 2 * hexRadius; // Width of the hexagon (flat-side to flat-side)
const hexHeight = Math.sqrt(3) * hexRadius; // Height of the hexagon (point to point)
const horizontalSpacing = hexWidth * 0.75; // Horizontal distance between columns
const verticalSpacing = hexHeight; // Vertical distance between rows

const directions = [
    [0, -1], [0, 1], [1, -1], [1, 0], [-1, 0], [-1, 1]
];


function generateTerrainReference() {
    const terrainReferenceContainer = document.getElementById("terrainReferenceBar");
    const terrainData = {
        "Î ÎµÎ´Î¹Î¬Î´ÎµÏ‚": "#C0CF8C",
        "Î”Î¬ÏƒÎ·": "#327129",
        "Î›ÏŒÏ†Î¿Î¹": "#B7A762",
        "Î’Î¿Ï…Î½Î¬": "#827746",
        "Î›Î¯Î¼Î½ÎµÏ‚": "#4682B4",
        "Î’Î¬Î»Ï„Î¿Î¹": "#6B8E23"
    };

    // Clear existing content
    terrainReferenceContainer.innerHTML = "";

    // Build terrain reference entries
    for (const [terrain, color] of Object.entries(terrainData)) {
        const terrainItem = document.createElement("div");
        terrainItem.style.display = "inline-block";
        terrainItem.style.margin = "0 10px";
        terrainItem.style.fontSize = "16px";
        terrainItem.innerHTML = `<span style="font-weight: bold; color:${color};">${terrain}</span>`;
        terrainReferenceContainer.appendChild(terrainItem);
    }
}

// Call this function to generate the terrain reference bar
generateTerrainReference();


// Helper Functions
function rollDice(sides) {
    return Math.floor(Math.random() * sides) + 1;
}

function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

function getRandomTerrain() {
    const roll = rollDice(36);
    if (roll <= 12) return "Plains";
    if (roll <= 21) return "Forest";
    if (roll <= 29) return "Hill";
    if (roll <= 34) return "Mountain";
    if (roll === 35) return "Swamp";
    if (roll === 36) return "Lake";
    return "Plains";
}

function getHexContent(terrain) {
            if (Math.random() > 1 / 6) return ""; // 1 ÏƒÏ„Î¹Ï‚ 6 Ï€Î¹Î¸Î±Î½ÏŒÏ„Î·Ï„ÎµÏ‚
            const roll = rollDice(6) * 10 + rollDice(6); // Î¡Î¯Î¾Îµ d66
            const table = hexContentTable[terrain];
            for (let [min, max, content] of table) {
                if (roll >= min && roll <= max) return content;
            }
            return "";
        }

    function drawHexContents(ctx, centerX, centerY, content) {
    if (!content) return; // Î‘Î½ Î´ÎµÎ½ Ï…Ï€Î¬ÏÏ‡ÎµÎ¹ Ï€ÎµÏÎ¹ÎµÏ‡ÏŒÎ¼ÎµÎ½Î¿, Î´ÎµÎ½ ÎºÎ¬Î½Î¿Ï…Î¼Îµ Ï„Î¯Ï€Î¿Ï„Î±
    // Î£Ï‡ÎµÎ´Î¯Î±ÏƒÎ· Ï€ÎµÏÎ¹ÎµÏ‡Î¿Î¼Î­Î½Î¿Ï… ÏƒÏ„Î¿ Î±ÎºÏÎ¹Î²Î­Ï‚ ÎºÎ­Î½Ï„ÏÎ¿
	ctx.font = "bold 15px Arial";
    ctx.fillStyle = "black";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(content, centerX, centerY);
    }

function drawHexagon(ctx, centerX, centerY, terrain) {
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 180) * (60 * i);
        const x = centerX + hexRadius * Math.cos(angle);
        const y = centerY + hexRadius * Math.sin(angle);
        if (i === 0) {
            ctx.moveTo(x, y);
        } else {
            ctx.lineTo(x, y);
        }
    }
    ctx.closePath();
    ctx.fillStyle = terrainColors[terrain];
    ctx.fill();
}

function drawHexLabel(ctx, centerX, centerY, row, col) {
    // Î£Ï‡ÎµÎ´Î¯Î±ÏƒÎ· ÏƒÏ…Î½Ï„ÎµÏ„Î±Î³Î¼Î­Î½Ï‰Î½ (Î»Î¯Î³Î¿ Ï€Î¬Î½Ï‰ Î±Ï€ÏŒ Ï„Î¿ ÎºÎ­Î½Ï„ÏÎ¿)
    ctx.font = "9px Arial";
    ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(`${row},${col}`, centerX, centerY - hexRadius * 0.6);
}

function drawHexGrid(ctx, mapData) {
    for (let row = 0; row < mapHeight; row++) {
        for (let col = 0; col < mapWidth; col++) {
            if (!mapData[row][col]) continue;
            const x = col * horizontalSpacing + hexRadius;
            const y = row * verticalSpacing + (col % 2) * (hexHeight / 2) + hexRadius;
            const terrain = mapData[row][col];  // Get the terrain for this hex
            const content = getHexContent(terrain);  // Get the content for this terrain

            drawHexagon(ctx, x, y, terrain);
            drawHexLabel(ctx, x, y, row, col);
            drawHexContents(ctx, x, y, content);  // Draw the content in the hex
        }
    }
}

function generateHexMap() {
    const mapData = Array.from({ length: mapHeight }, () => Array(mapWidth).fill(null));
    let filledCells = 0; // Track the number of filled cells
    const totalCells = mapWidth * mapHeight; // Total number of cells in the grid

    while (filledCells < totalCells) {
        const row = rollDice(mapHeight) - 1;
        const col = rollDice(mapWidth) - 1;

        // Skip if the current cell is already filled
        if (mapData[row][col]) continue;

        // Gather neighbors into a 6-element array
        const neighbors = directions.map(([dr, dc]) => {
            const adjRow = row + dr;
            const adjCol = col + dc;

            // Check bounds and return either the terrain type or undefined
            if (
                adjRow >= 0 && adjRow < mapHeight &&
                adjCol >= 0 && adjCol < mapWidth
            ) {
                return mapData[adjRow][adjCol] || undefined;
            } else {
                return undefined;
            }
        });

        // Choose terrain based on neighbors
        const chosenNeighbor = neighbors[Math.floor(Math.random() * neighbors.length)];
        if (chosenNeighbor === undefined) {
            // If undefined is chosen, generate a completely random terrain
            mapData[row][col] = getRandomTerrain();
        } else {
            // If a defined neighbor is chosen, determine terrain based on base/metabasis
            const roll = rollDice(6);
            mapData[row][col] = roll <= 2 ? chosenNeighbor : metabasisMap[chosenNeighbor] || chosenNeighbor;
        }

        filledCells++; // Increment the count of filled cells
    }

    return mapData;
}



// Main Function
function main() {
    const canvas = document.createElement('canvas');
    const screenWidth = Math.ceil(mapWidth * horizontalSpacing + hexRadius);
    const screenHeight = Math.ceil(mapHeight * verticalSpacing + hexRadius);
    canvas.width = screenWidth;
    canvas.height = screenHeight;
    document.body.appendChild(canvas);

    const generateButton = document.getElementById("generateButton");
    const widthInput = document.getElementById("width");
    const heightInput = document.getElementById("height");


    const ctx = canvas.getContext('2d');
    const hexMap = generateHexMap();

    function regenerateMap() {
        // Read values from input boxes
        const newWidth = parseInt(widthInput.value, 10);
        const newHeight = parseInt(heightInput.value, 10);

        // Validate the input
        if (isNaN(newWidth) || isNaN(newHeight) || newWidth < 1 || newHeight < 1) {
            alert("Please enter valid positive integers for width and height.");
            return;
        }

        // Update global dimensions
        mapWidth = newWidth;
        mapHeight = newHeight;

        // Adjust canvas size
        const screenWidth = Math.ceil(mapWidth * horizontalSpacing + hexRadius);
        const screenHeight = Math.ceil(mapHeight * verticalSpacing + hexRadius);
        canvas.width = screenWidth;
        canvas.height = screenHeight;

        // Generate a new map and draw it
        const ctx = canvas.getContext("2d");
        const hexMap = generateHexMap();

        // Clear the canvas and redraw the map
        function render() {
            ctx.fillStyle = "#F4F4F4";
            ctx.fillRect(0, 0, screenWidth, screenHeight);
            drawHexGrid(ctx, hexMap);
        }

        render();
    }

    // Attach event listener to the button
    generateButton.addEventListener("click", regenerateMap);

    // Generate the initial map on page load
    regenerateMap();
}
    


// Run the main function
main();
function generateLegend() {
    const legendContainer = document.getElementById("legend");
    const legendData = {
        "ğŸ ": "ÎŸÎ¹ÎºÎ¹ÏƒÎ¼ÏŒÏ‚",
        "â›ª": "ÎšÏ„Î®ÏÎ¹Î¿",
        "ğŸ’€": "Î›Î·Î¼Î­ÏÎ¹",
        "ğŸª¦": "Î•ÏÎµÎ¯Ï€Î¹Î¿",
        "ğŸŒ€": "Î›Î±Î²ÏÏÎ¹Î½Î¸Î¿Ï‚",
        "âš¡": "Î‘ÏƒÏ…Î½Î®Î¸Î¹ÏƒÏ„Î¿",
        "ğŸŒ²": "Î¦Ï…ÏƒÎ¹ÎºÏŒ Î§Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ"
    };

    // Clear existing content
    legendContainer.innerHTML = "";

    // Build legend entries
    for (const [icon, label] of Object.entries(legendData)) {
        const legendItem = document.createElement("div");
        legendItem.style.display = "inline-block";
        legendItem.style.margin = "0 10px";
        legendItem.style.fontSize = "16px";
        legendItem.innerHTML = `<span style="font-weight: bold;">${icon}</span> - ${label}`;
        legendContainer.appendChild(legendItem);
    }
}

// Call this function after the DOM is loaded
generateLegend();

    </script>
</body>
</html>
