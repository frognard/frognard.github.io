


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Î“ÎµÎ½Î½Î®Ï„ÏÎ¹Î± Î¤Î¿Ï€Î¯Î¿Ï…</title>
    <style>
        body {
            margin: 0;
            background-color: #f4f4f4;
        }
        canvas {
            display: block;
            margin: 30px auto 0 auto;
            padding: 0;
          
        }
     </style>
</head>
<body>
    <div style="text-align: center; background-color: #ddd; padding: 10px; font-family: Arial, sans-serif; font-size: 12px;">
        <!-- Terrain features -->
        <div style="margin-bottom: 10px;">
            <span style="margin: 0 10px;"><span style="font-weight: bold;">ğŸ </span> - ÎŸÎ¹ÎºÎ¹ÏƒÎ¼ÏŒÏ‚</span>
            <span style="margin: 0 10px;"><span style="font-weight: bold;">â›ª</span> - ÎšÏ„Î®ÏÎ¹Î¿</span>
            <span style="margin: 0 10px;"><span style="font-weight: bold;">ğŸ’€</span> - Î›Î·Î¼Î­ÏÎ¹</span>
            <span style="margin: 0 10px;"><span style="font-weight: bold;">ğŸª¦</span> - Î•ÏÎµÎ¯Ï€Î¹Î¿</span>
            <span style="margin: 0 10px;"><span style="font-weight: bold;">ğŸŒ€</span> - Î›Î±Î²ÏÏÎ¹Î½Î¸Î¿Ï‚</span>
            <span style="margin: 0 10px;"><span style="font-weight: bold;">âš¡</span> - Î‘ÏƒÏ…Î½Î®Î¸Î¹ÏƒÏ„Î¿</span>
            <span style="margin: 0 10px;"><span style="font-weight: bold;">ğŸŒ²</span> - Î¦Ï…ÏƒÎ¹ÎºÏŒ Î§Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÏŒ</span>
        </div>

        <!-- Color-coded terrain types -->
        <div>
            <span style="margin: 0 10px; padding: 5px; background-color: #C0CF8C; color: #000; font-weight: bold;">Î ÎµÎ´Î¹Î¬Î´ÎµÏ‚</span>
            <span style="margin: 0 10px; padding: 5px; background-color: #327129; color: #000; font-weight: bold;">Î”Î¬ÏƒÎ·</span>
            <span style="margin: 0 10px; padding: 5px; background-color: #B7A762; color: #000; font-weight: bold;">Î›ÏŒÏ†Î¿Î¹</span>
            <span style="margin: 0 10px; padding: 5px; background-color: #827746; color: #000; font-weight: bold;">Î’Î¿Ï…Î½Î¬</span>
            <span style="margin: 0 10px; padding: 5px; background-color: #4682B4; color: #000; font-weight: bold;">Î›Î¯Î¼Î½ÎµÏ‚</span>
            <span style="margin: 0 10px; padding: 5px; background-color: #6B8E23; color: #000; font-weight: bold;">Î’Î¬Î»Ï„Î¿Î¹</span>
        </div>
    </div>   
    
    <div>
      
        <style>
            #width, #height, #RadiusIn {
              width: 50px;
              margin-right: 10px;
              
            }
            button {
              padding: 5px 10px;
            }
            div {
              margin-bottom: 0px;
              text-align: center;
              margin: 10px;
              margin-top: 0px;
            }
          </style>
          
        <!-- Add the width and height textboxes -->
        <label for="width">Î Î»Î¬Ï„Î¿Ï‚:</label>
        <input type="number" id="width" name="width" min="1" value="16">
        <label for="height">ÎÏˆÎ¿Ï‚:</label>
        <input type="number" id="height" name="height" min="1" value="12">
        <label for="RadiusIn">ÎœÎ­Î³ÎµÎ¸Î¿Ï‚ Î•Î¾Î±Î³ÏÎ½Î¿Ï…:</label>
        <input type="number" id="RadiusIn" name="RadiusIn" min="1" value="30">
        
        <!-- Add the generate button -->
        <button id="generateButton">Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î± Î§Î¬ÏÏ„Î·</button>
      </div>

      

    <script>
// Constants
let hexRadius = 10;
let mapWidth = 16;  // Number of columns
let mapHeight = 12; // Number of rows



const terrainColors = {
    "Plains": "#C0CF8C",
    "Forest": "#327129",
    "Hill": "#B7A762",
    "Mountain": "#827746",
    "Lake": "#4682B4",
    "Swamp": "#6B8E23"
};

const metabasisMap = {
    "Plains": "Forest",
    "Forest": "Plains",
    "Hill": "Mountain",
    "Mountain": "Hill",
    "Lake": "Swamp",
    "Swamp": "Lake"
};

const hexContentTable = {
            Plains: [
                [11, 25, "ğŸ "], [26, 42, "â›ª"], [43, 52, "ğŸ’€"],
                [53, 55, "ğŸª¦"], [56, 63, "ğŸŒ²"], [64, 65, "âš¡"], [66, "ğŸŒ€"]
            ],
            Forest: [
                [11, 16, "ğŸ "], [21, 31, "â›ª"], [32, 46, "ğŸ’€"],
                [51, 53, "ğŸª¦"], [54, 61, "ğŸŒ²"], [62, 64, "âš¡"], [65, 66, "ğŸŒ€"]
            ],
            Hill: [
                [11, 22, "ğŸ "], [23, 33, "â›ª"], [34, 46, "ğŸ’€"],
                [51, 53, "ğŸª¦"], [54, 61, "ğŸŒ²"], [62, 63, "âš¡"], [64, 66, "ğŸŒ€"]
            ],
            Mountain: [
                [11, 15, "ğŸ "], [16, 24, "â›ª"], [25, 44, "ğŸ’€"],
                [45, 51, "ğŸª¦"], [52, 55, "ğŸŒ²"], [56, 63, "âš¡"], [64, 66, "ğŸŒ€"]
            ],
            Swamp: [
                [11, 13, "ğŸ "], [14, 16, "â›ª"], [21, 36, "ğŸ’€"],
                [41, 52, "ğŸª¦"], [53, 56, "ğŸŒ²"], [61, 64, "âš¡"], [65, 66, "ğŸŒ€"]
            
            ],
            Lake: [
                [11, 13, ""], [14, 16, ""], [21, 36, ""],
                [41, 52, ""], [53, 56, ""], [61, 64, ""], [65, 66, ""]
        ]
        };

let hexWidth = 2 * hexRadius; // Width of the hexagon (flat-side to flat-side)
let hexHeight = Math.sqrt(3) * hexRadius; // Height of the hexagon (point to point)
let horizontalSpacing = hexWidth * 0.75; // Horizontal distance between columns
let verticalSpacing = hexHeight; // Vertical distance between rows

const directions = [
    [0, -1], [0, 1], [1, -1], [1, 0], [-1, 0], [-1, 1]
];


// Helper Functions
function rollDice(sides) {
    return Math.floor(Math.random() * sides) + 1;
}

function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

function getRandomTerrain() {
    const roll = rollDice(36);
    if (roll <= 12) return "Plains";
    if (roll <= 21) return "Forest";
    if (roll <= 29) return "Hill";
    if (roll <= 34) return "Mountain";
    if (roll === 35) return "Swamp";
    if (roll === 36) return "Lake";
    return "Plains";
}

function getHexContent(terrain) {
            if (Math.random() > 1 / 6) return ""; // 1 ÏƒÏ„Î¹Ï‚ 6 Ï€Î¹Î¸Î±Î½ÏŒÏ„Î·Ï„ÎµÏ‚
            const roll = rollDice(6) * 10 + rollDice(6); // Î¡Î¯Î¾Îµ d66
            const table = hexContentTable[terrain];
            for (let [min, max, content] of table) {
                if (roll >= min && roll <= max) return content;
            }
            return "";
        }

    function drawHexContents(ctx, centerX, centerY, content) {
    if (!content) return; // Î‘Î½ Î´ÎµÎ½ Ï…Ï€Î¬ÏÏ‡ÎµÎ¹ Ï€ÎµÏÎ¹ÎµÏ‡ÏŒÎ¼ÎµÎ½Î¿, Î´ÎµÎ½ ÎºÎ¬Î½Î¿Ï…Î¼Îµ Ï„Î¯Ï€Î¿Ï„Î±
    // Î£Ï‡ÎµÎ´Î¯Î±ÏƒÎ· Ï€ÎµÏÎ¹ÎµÏ‡Î¿Î¼Î­Î½Î¿Ï… ÏƒÏ„Î¿ Î±ÎºÏÎ¹Î²Î­Ï‚ ÎºÎ­Î½Ï„ÏÎ¿
	ctx.font = "bold 15px Arial";
    ctx.fillStyle = "black";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(content, centerX, centerY);
    }

function drawHexagon(ctx, centerX, centerY, terrain) {
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 180) * (60 * i);
        const x = centerX + hexRadius * Math.cos(angle);
        const y = centerY + hexRadius * Math.sin(angle);
        if (i === 0) {
            ctx.moveTo(x, y);
        } else {
            ctx.lineTo(x, y);
        }
    }
    ctx.closePath();
    ctx.fillStyle = terrainColors[terrain];
    ctx.fill();
}

function drawHexLabel(ctx, centerX, centerY, row, col) {
    // Î£Ï‡ÎµÎ´Î¯Î±ÏƒÎ· ÏƒÏ…Î½Ï„ÎµÏ„Î±Î³Î¼Î­Î½Ï‰Î½ (Î»Î¯Î³Î¿ Ï€Î¬Î½Ï‰ Î±Ï€ÏŒ Ï„Î¿ ÎºÎ­Î½Ï„ÏÎ¿)
    ctx.font = "9px Arial";
    ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(`${row},${col}`, centerX, centerY - hexRadius * 0.6);
}

function drawHexGrid(ctx, mapData) {
    for (let row = 0; row < mapHeight; row++) {
        for (let col = 0; col < mapWidth; col++) {
            if (!mapData[row][col]) continue;
            const x = col * horizontalSpacing + hexRadius;
            const y = row * verticalSpacing + (col % 2) * (hexHeight / 2) + hexRadius;
            const terrain = mapData[row][col];  // Get the terrain for this hex
            const content = getHexContent(terrain);  // Get the content for this terrain

            drawHexagon(ctx, x, y, terrain);
            drawHexLabel(ctx, x, y, row, col);
            drawHexContents(ctx, x, y, content);  // Draw the content in the hex
        }
    }
}

function generateHexMap() {
    const mapData = Array.from({ length: mapHeight }, () => Array(mapWidth).fill(null));
    let filledCells = 0; // Track the number of filled cells
    const totalCells = mapWidth * mapHeight; // Total number of cells in the grid

    while (filledCells < totalCells) {
        const row = rollDice(mapHeight) - 1;
        const col = rollDice(mapWidth) - 1;

        // Skip if the current cell is already filled
        if (mapData[row][col]) continue;

        // Gather neighbors into a 6-element array
        const neighbors = directions.map(([dr, dc]) => {
            const adjRow = row + dr;
            const adjCol = col + dc;

            // Check bounds and return either the terrain type or undefined
            if (
                adjRow >= 0 && adjRow < mapHeight &&
                adjCol >= 0 && adjCol < mapWidth
            ) {
                return mapData[adjRow][adjCol] || undefined;
            } else {
                return undefined;
            }
        });

        // Choose terrain based on neighbors
        const chosenNeighbor = neighbors[Math.floor(Math.random() * neighbors.length)];
        if (chosenNeighbor === undefined) {
            // If undefined is chosen, generate a completely random terrain
            mapData[row][col] = getRandomTerrain();
        } else {
            // If a defined neighbor is chosen, determine terrain based on base/metabasis
            const roll = rollDice(6);
            mapData[row][col] = roll <= 2 ? chosenNeighbor : metabasisMap[chosenNeighbor] || chosenNeighbor;
        }

        filledCells++; // Increment the count of filled cells
    }

    return mapData;
}



// Main Function
function main() {
    const canvas = document.createElement('canvas');
    const screenWidth = Math.ceil(mapWidth * horizontalSpacing + hexRadius);
    const screenHeight = Math.ceil(mapHeight * verticalSpacing + hexRadius);
    canvas.width = screenWidth;
    canvas.height = screenHeight;
    document.body.appendChild(canvas);

    const generateButton = document.getElementById("generateButton");
    const widthInput = document.getElementById("width");
    const heightInput = document.getElementById("height");
    const RadiusInput = document.getElementById("RadiusIn");


    const ctx = canvas.getContext('2d');
    const hexMap = generateHexMap();

    function regenerateMap() {
        // Read values from input boxes
        const newWidth = parseInt(widthInput.value, 10);
        const newHeight = parseInt(heightInput.value, 10);
        const newRadius = parseInt(RadiusInput.value, 10);

        // Validate the input
        if (isNaN(newWidth) || isNaN(newHeight) || isNaN(newRadius) || newWidth < 1 || newHeight < 1 || newRadius < 1) {
            alert("Please enter valid positive integers for width and height.");
            return;
        }

        // Update global dimensions
        mapWidth = newWidth;
        mapHeight = newHeight;
        hexRadius = newRadius;

        // Recalculate hex dimensions
        hexWidth = 2 * hexRadius;
        hexHeight = Math.sqrt(3) * hexRadius;
        horizontalSpacing = hexWidth * 0.75;
        verticalSpacing = hexHeight;

        // Adjust canvas size
         const screenWidth = Math.ceil(mapWidth * horizontalSpacing + hexRadius);
        const screenHeight = Math.ceil(mapHeight * verticalSpacing + hexRadius);
        canvas.width = screenWidth;
        canvas.height = screenHeight;
        
        
        // Generate a new map and draw it
        const ctx = canvas.getContext("2d");
        const hexMap = generateHexMap();

        // Clear the canvas and redraw the map
        function render() {
            ctx.fillStyle = "#F4F4F4";
            ctx.fillRect(0, 0, screenWidth, screenHeight);
            drawHexGrid(ctx, hexMap);
        }

        render();
    }

    // Attach event listener to the button
    generateButton.addEventListener("click", regenerateMap);

    // Generate the initial map on page load
    regenerateMap();
}
    


// Run the main function
main();



    </script>
</body>
</html>
